#include "stm32l4xx_hal.h"
#define CE_PORT GPIOB // PB6 chip enable (aka slave select)
#define CE_PIN GPIO_PIN_6
#define DC_PORT GPIOA // PA0 data/control
#define DC_PIN GPIO_PIN_0
#define RESET_PORT GPIOA // PA1 reset
#define RESET_PIN GPIO_PIN_1
#define GLCD_WIDTH 84
#define GLCD_HEIGHT 48
#define NUM_BANKS 6

const char pixels[8] = {0x01, 0x02, 0x04, 0x08,
				  0x10, 0x20, 0x40, 0x80};

const char number_font_table[][6] = {
		{0x7F, 0x41, 0x41, 0x41, 0x7F, 0x00}, // 0
		{0x00, 0x42, 0x7F, 0x40, 0x00, 0x00}, // 1
		{0x79, 0x49, 0x49, 0x49, 0x4F, 0x00}, // 2
		{0x49, 0x49, 0x49, 0x49, 0x7F, 0x00}, // 3
		{0x0F, 0x08, 0x08, 0x08, 0x7F, 0x00}, // 4
		{0x4F, 0x49, 0x49, 0x49, 0x79, 0x00}, // 5
		{0x7F, 0x49, 0x49, 0x49, 0x79, 0x00}, // 6
		{0x01, 0x01, 0x01, 0x01, 0x7F, 0x00}, // 7
		{0x7F, 0x49, 0x49, 0x49, 0x7F, 0x00}, // 8
		{0x0F, 0x09, 0x09, 0x09, 0x7F, 0x00}  // 9
};

const char font_table[][6] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // space 0
	{0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00}, // 'A'   1
	{0x7F, 0x49, 0x49, 0x49, 0x36, 0x00}, // 'B'   2
	{0x3E, 0x41, 0x41, 0x41, 0x22, 0x00}, // 'C'   3
	{0x7F, 0x41, 0x41, 0x41, 0x3E, 0x00}, // 'D'   4
	{0x7F, 0x49, 0x49, 0x49, 0x49, 0x00}, // 'E'   5
	{0x7F, 0x09, 0x09, 0x09, 0x09, 0x00}, // 'F'   6
	{0x7F, 0x41, 0x49, 0x49, 0x79, 0x00}, // 'G'   7
	{0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00}, // 'H'   8
	{0x41, 0x41, 0x7F, 0x41, 0x41, 0x00}, // 'I'   9
	{0x20, 0x40, 0x41, 0x3F, 0x01, 0x00}, // 'J'   10
	{0x7F, 0x08, 0x14, 0x22, 0x41, 0x00}, // 'K'   11
	{0x7F, 0x40, 0x40, 0x40, 0x40, 0x00}, // 'L'   12
	{0x7F, 0x02, 0x04, 0x02, 0x7F, 0x00}, // 'M'   13
	{0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00}, // 'N'   14
	{0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00}, // 'O'   15
	{0x7E, 0x09, 0x09, 0x09, 0x06, 0x00}, // 'P'   16
	{0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00}, // 'Q'   17
	{0x7E, 0x09, 0x19, 0x29, 0x46, 0x00}, // 'R'   18
	{0x46, 0x49, 0x49, 0x49, 0x31, 0x00}, // 'S'   19
	{0x01, 0x01, 0x7F, 0x01, 0x01, 0x00}, // 'T'   20
	{0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00}, // 'U'   21
	{0x07, 0x38, 0x40, 0x38, 0x07, 0x00}, // 'V'   22
	{0x7F, 0x20, 0x10, 0x20, 0x7F, 0x00}, // 'W'   23
	{0x63, 0x14, 0x08, 0x14, 0x63, 0x00}, // 'X'   24
	{0x03, 0x0C, 0x70, 0x0C, 0x03, 0x00}, // 'Y'   25
	{0x41, 0x51, 0x49, 0x45, 0x43, 0x00}, // 'Z'   26
	{0x00, 0x00, 0x7E, 0x81, 0xB5, 0xA1}, // ')'   27
	{0xA1, 0xB5, 0x81, 0x7E, 0x00, 0x00}, // ')'   28
	{0x00, 0x66, 0x66, 0x00, 0x00, 0x00}, // ':'   29
};

class Screen
{
public:
	// Constructor
	Screen(SPI_HandleTypeDef &hspi1) : hspi1(hspi1) {
		// INIT SCREEN ARRAY
		GLCD_setCursor(0,0);
		for (size_t i = 0; i < GLCD_WIDTH; i++)
		{
			for(size_t j = 0; j < GLCD_HEIGHT / 8; j++)
			{
				screen[i][j] = 0x00;
			}
		}

		GLCD_init();
		GLCD_clear();
	};

	void setPixel(int x, int y);

	void initScreen();

	void clearScreen();
	void displayScreen(int score); // To Do: Probably shouldn't have score.
								   // Wrapper Game class later?
	void displayGameOver(int score);

	bool pixelTaken(int x, int y);
private:
	// Screen Methods
	void displayScore(int score);

	// GLCD Methods
	void SPI_write(unsigned char data);
	void GLCD_data_write(unsigned char data);
	void GLCD_command_write(unsigned char data);
	void GLCD_init(void);
	void GLCD_setCursor(unsigned char x, unsigned char y);
	void GLCD_clear(void);
	void GLCD_putchar(int font_table_row);
	void GLCD_putnum(int font_table_row);

	// Attributes
	char screen[GLCD_WIDTH][GLCD_HEIGHT/8];
	SPI_HandleTypeDef &hspi1;
};
